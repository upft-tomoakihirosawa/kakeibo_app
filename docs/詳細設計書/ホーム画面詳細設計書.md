# ホーム画面 詳細設計書

---

## 1. ドキュメント管理

- 文書名: ホーム画面 詳細設計書
- 作成者: 廣澤
- 作成日: 2025-05-16

---

## 2. 画面概要

ホーム画面は、ユーザーが当月の家計状況を一目で把握できる中心的な画面です。収入・支出の合計、グラフ表示、予算達成度などを視覚的に表示し、他画面へのナビゲーションも提供します。

---

## 3. 画面レイアウト構成

画面レイアウトの詳細は [ホーム画面レイアウト](/Users/tomoaki.hirosawa/Documents/develop/kakeibo-app/doc/詳細設計書/画面レイアウト/ホーム画面.html) を参照してください。

### 3.1 画面構成要素

| コンポーネント | 説明 | 実装クラス |
|--------------|------|----------|
| ヘッダー部 | アプリタイトル、通知・設定へのアクセスボタンを表示 | `HomeScreen` |
| 月選択セレクター | 表示する月を選択するためのコントロール | `MonthSelector` |
| 月間サマリーカード | 選択月の収入・支出・残高を表示するカード | `MonthlySummaryCard` |
| カテゴリ別支出チャート | カテゴリごとの支出を視覚的に表す円グラフまたは棒グラフ | `CategoryChart` |
| 最近の取引リスト | 最新の取引記録を表示するリスト | `RecentTransactionsList` |
| 予算進捗表示 | 予算に対する支出の進捗を表示するプログレスバー | `BudgetProgressBar` |
| 新規取引追加ボタン | 取引追加画面へ遷移するフローティングボタン | `FloatingActionButton` |
| 下部ナビゲーションバー | 他の主要画面へのナビゲーションを提供するバー | `AppBottomNavigation` |

### 3.2 データ表示項目

#### 月間サマリー
- **収入合計**: 選択月の収入の合計金額
- **支出合計**: 選択月の支出の合計金額
- **残高**: 収入合計 - 支出合計の差額
- **前月比**: 前月との収支比較（%）

#### カテゴリ別支出
- **カテゴリ名**: 支出カテゴリの名称
- **金額**: カテゴリごとの合計支出額
- **割合**: 全体支出に対する各カテゴリの割合（%）
- **視覚表現**: 円グラフまたは棒グラフによる視覚化

#### 最近の取引
- **日付**: 取引が行われた日付
- **カテゴリ**: 取引のカテゴリ
- **説明**: 取引の内容説明
- **金額**: 取引金額（収入/支出）

#### 予算進捗
- **総合進捗**: 月間予算に対する現在の支出進捗率（%）
- **カテゴリ別進捗**: カテゴリごとの予算達成度（%）
- **残り予算**: 予算残高の表示

---

## 4. クラス設計

ホーム画面の実装に関わる主要クラスは以下の通りです。詳細な実装はリンク先のクラス定義ドキュメントを参照してください。

### 4.1 画面クラス

- [HomeScreen](/Users/tomoaki.hirosawa/Documents/develop/kakeibo-app/doc/詳細設計書/クラス定義/HomeScreen.md) - ホーム画面の基本構造とコンポーネント配置を実装

### 4.2 状態管理クラス

- [HomeProviders](/Users/tomoaki.hirosawa/Documents/develop/kakeibo-app/doc/詳細設計書/クラス定義/HomeProviders.md) - ホーム画面で使用される各種データを提供するプロバイダー

---

## 5. データフロー

### 5.1 データ取得フロー

1. **画面初期化時**:
   - `HomeScreen`の`build`メソッド内で各種プロバイダーをwatch
   - 現在選択中の月のデータがプロバイダーから自動的に取得・表示される

2. **月変更時**:
   - `MonthSelector`で月が変更されると`selectedMonthYearProvider`の状態が更新
   - 依存する各プロバイダー（`monthlySummaryProvider`, `categoryExpensesProvider`等）が自動的に再取得を実行

3. **Pull-to-Refresh時**:
   - `RefreshIndicator`の`onRefresh`コールバックでプロバイダーをリフレッシュ
   - 最新データが取得され、UI全体が更新される

4. **取引追加後**:
   - 新規取引追加画面から戻った時、必要に応じてデータをリフレッシュ

### 5.2 データ変換処理

1. **取引データ → サマリーデータへの集計**:
   - 期間内の取引リストから収入・支出を集計
   - `MonthlySummary`モデルに変換

2. **取引データ → カテゴリ別データへの変換**:
   - カテゴリIDでグループ化し、各カテゴリの合計金額を計算
   - 全体に対する割合（%）を計算
   - `CategoryExpense`モデルのリストに変換

3. **予算と実際の支出 → 進捗データへの変換**:
   - 予算データと実際の支出データを比較
   - 達成率の計算
   - `BudgetProgress`モデルに変換

---

## 6. 画面状態管理

### 6.1 ローディング状態

```dart
// データ読み込み中の表示
ref.watch(monthlySummaryProvider).when(
  data: (summary) => MonthlySummaryCard(summary: summary),
  loading: () => const ShimmerLoadingCard(height: 120),
  error: (error, stackTrace) => ErrorWidget(
    message: 'データの取得に失敗しました',
    onRetry: () => ref.refresh(monthlySummaryProvider),
  ),
)
```

### 6.2 エラー状態

```dart
// エラー発生時の表示
ref.watch(categoryExpensesProvider).when(
  data: (categories) => categories.isNotEmpty
      ? CategoryChartWidget(categories: categories)
      : const EmptyStateWidget(message: 'データがありません'),
  loading: () => const ShimmerLoadingCard(height: 200),
  error: (error, stackTrace) => ErrorWidget(
    message: 'カテゴリデータの取得に失敗しました',
    onRetry: () => ref.refresh(categoryExpensesProvider),
  ),
)
```

### 6.3 空データ状態

```dart
// データ不在時の表示
ref.watch(recentTransactionsProvider).when(
  data: (transactions) => transactions.isNotEmpty
      ? RecentTransactionsList(transactions: transactions)
      : const EmptyStateWidget(
          icon: Icons.receipt_long,
          message: '取引データがありません',
          description: '右下のボタンから取引を追加してください',
        ),
  loading: () => const TransactionsLoadingSkeleton(),
  error: (error, stackTrace) => ErrorWidget(
    message: '取引データの取得に失敗しました',
    onRetry: () => ref.refresh(recentTransactionsProvider),
  ),
)
```

---

## 7. ユーザーインタラクション

### 7.1 月の切り替え

```dart
Widget _buildMonthSelector(BuildContext context, WidgetRef ref) {
  final selectedDate = ref.watch(selectedMonthYearProvider);
  final dateFormat = DateFormat('yyyy年M月', 'ja_JP');
  
  return Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
      IconButton(
        icon: const Icon(Icons.chevron_left),
        onPressed: () {
          final newDate = DateTime(
            selectedDate.year,
            selectedDate.month - 1,
            1,
          );
          ref.read(selectedMonthYearProvider.notifier).state = newDate;
        },
      ),
      GestureDetector(
        onTap: () async {
          final picked = await showMonthPicker(
            context: context,
            initialDate: selectedDate,
            firstDate: DateTime(2020),
            lastDate: DateTime.now(),
            locale: const Locale('ja'),
          );
          if (picked != null) {
            ref.read(selectedMonthYearProvider.notifier).state = picked;
          }
        },
        child: Text(
          dateFormat.format(selectedDate),
          style: Theme.of(context).textTheme.titleLarge,
        ),
      ),
      IconButton(
        icon: const Icon(Icons.chevron_right),
        onPressed: DateTime(
                  selectedDate.year,
                  selectedDate.month,
                ).isAfter(DateTime(
                  DateTime.now().year,
                  DateTime.now().month,
                ))
            ? null // 未来の月は選択不可
            : () {
                final newDate = DateTime(
                  selectedDate.year,
                  selectedDate.month + 1,
                  1,
                );
                ref.read(selectedMonthYearProvider.notifier).state = newDate;
              },
      ),
    ],
  );
}
```

### 7.2 取引追加

```dart
FloatingActionButton(
  onPressed: () async {
    final result = await Navigator.pushNamed(
      context,
      '/transaction/add',
    );
    
    // 取引追加後、データをリフレッシュ
    if (result == true) {
      ref.refresh(monthlySummaryProvider);
      ref.refresh(categoryExpensesProvider);
      ref.refresh(recentTransactionsProvider);
      
      // スナックバーでフィードバック
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('取引を追加しました')),
      );
    }
  },
  child: const Icon(Icons.add),
  tooltip: '取引を追加',
)
```

### 7.3 カテゴリ詳細表示

```dart
GestureDetector(
  onTap: () {
    Navigator.pushNamed(
      context,
      '/category-details',
      arguments: CategoryDetailsArguments(
        category: category,
        month: ref.watch(selectedMonthYearProvider),
      ),
    );
  },
  child: CategoryListItem(
    category: category,
    showProgress: true,
  ),
)
```

### 7.4 取引詳細表示

```dart
GestureDetector(
  onTap: () async {
    final result = await Navigator.pushNamed(
      context,
      '/transaction/details',
      arguments: transaction.id,
    );
    
    // 取引編集または削除後、データをリフレッシュ
    if (result == true) {
      ref.refresh(monthlySummaryProvider);
      ref.refresh(categoryExpensesProvider);
      ref.refresh(recentTransactionsProvider);
    }
  },
  child: TransactionListItem(transaction: transaction),
)
```

---

## 8. レスポンシブ対応

### 8.1 デバイス別レイアウト

#### スマートフォン（縦向き）
- 単一カラムレイアウト
- コンポーネントが縦に積み重なる

#### タブレット／スマートフォン（横向き）
- 2カラムレイアウト
- 左側：月間サマリー、予算進捗
- 右側：カテゴリチャート、最近の取引

#### 実装例

```dart
Widget _buildResponsiveLayout(BuildContext context, WidgetRef ref) {
  final screenWidth = MediaQuery.of(context).size.width;
  
  if (screenWidth > 600) {
    // タブレット/横向きレイアウト
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(
          flex: 1,
          child: Column(
            children: [
              _buildMonthlySummaryCard(context, ref),
              const SizedBox(height: 16),
              _buildBudgetProgress(context, ref),
            ],
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          flex: 1,
          child: Column(
            children: [
              _buildCategoryCharts(context, ref),
              const SizedBox(height: 16),
              _buildRecentTransactions(context, ref),
            ],
          ),
        ),
      ],
    );
  } else {
    // スマートフォン縦向きレイアウト
    return Column(
      children: [
        _buildMonthlySummaryCard(context, ref),
        const SizedBox(height: 16),
        _buildCategoryCharts(context, ref),
        const SizedBox(height: 16),
        _buildBudgetProgress(context, ref),
        const SizedBox(height: 16),
        _buildRecentTransactions(context, ref),
      ],
    );
  }
}
```

### 8.2 グラフ表示の適応

```dart
Widget _buildCategoryCharts(BuildContext context, WidgetRef ref) {
  final screenWidth = MediaQuery.of(context).size.width;
  final isSmallScreen = screenWidth < 360; // 非常に小さい画面
  
  return ref.watch(categoryExpensesProvider).when(
    data: (categories) {
      if (categories.isEmpty) {
        return const EmptyStateWidget(message: '支出データがありません');
      }
      
      // 画面サイズに応じてチャートタイプを変更
      return isSmallScreen
          ? CategoryBarChart(categories: categories) // 棒グラフ
          : CategoryPieChart(categories: categories); // 円グラフ
    },
    loading: () => const ShimmerLoadingCard(height: 200),
    error: (e, st) => ErrorWidget(message: 'データの読み込みに失敗しました'),
  );
}
```

---

## 9. テスト計画

### 9.1 単体テスト

#### Provider テスト

```dart
group('monthlySummaryProvider tests', () {
  late MockTransactionRepository mockRepository;
  
  setUp(() {
    mockRepository = MockTransactionRepository();
  });
  
  test('monthlySummaryProvider loads correct data', () async {
    // モックデータをセットアップ
    when(() => mockRepository.getTotalIncome(any(), any()))
        .thenAnswer((_) async => 1000.0);
    when(() => mockRepository.getTotalExpense(any(), any()))
        .thenAnswer((_) async => 600.0);
    
    final container = ProviderContainer(
      overrides: [
        transactionRepositoryProvider.overrideWithValue(mockRepository),
        selectedMonthYearProvider.overrideWithValue(
          DateTime(2025, 5, 1),
        ),
      ],
    );
    
    // プロバイダからデータを取得
    final summary = await container.read(monthlySummaryProvider.future);
    
    // 期待する結果を検証
    expect(summary.income, 1000.0);
    expect(summary.expense, 600.0);
    expect(summary.balance, 400.0);
    
    verify(() => mockRepository.getTotalIncome(
      DateTime(2025, 5, 1),
      DateTime(2025, 5, 31),
    )).called(1);
    
    verify(() => mockRepository.getTotalExpense(
      DateTime(2025, 5, 1),
      DateTime(2025, 5, 31),
    )).called(1);
  });
});
```

### 9.2 UI テスト

#### ホーム画面のウィジェットテスト

```dart
testWidgets('HomeScreen displays data correctly', (tester) async {
  // モックプロバイダを準備
  final mockMonthlySummary = MonthlySummary(
    month: DateTime(2025, 5, 1),
    income: 1000.0,
    expense: 600.0,
    balance: 400.0,
  );
  
  final mockCategoryExpenses = [
    CategoryExpense(
      categoryId: 'food',
      categoryName: '食費',
      amount: 300.0,
      color: Colors.red,
      percentage: 50.0,
    ),
    CategoryExpense(
      categoryId: 'transport',
      categoryName: '交通費',
      amount: 200.0,
      color: Colors.blue,
      percentage: 33.3,
    ),
    CategoryExpense(
      categoryId: 'utilities',
      categoryName: '光熱費',
      amount: 100.0,
      color: Colors.green,
      percentage: 16.7,
    ),
  ];
  
  final mockTransactions = [
    Transaction(
      id: '1',
      amount: 300.0,
      categoryId: 'food',
      date: DateTime(2025, 5, 15),
      description: 'スーパーでの買い物',
      type: TransactionType.expense,
    ),
    Transaction(
      id: '2',
      amount: 1000.0,
      categoryId: 'salary',
      date: DateTime(2025, 5, 25),
      description: '給料',
      type: TransactionType.income,
    ),
  ];
  
  // テスト用のProviderScopeでラップ
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        monthlySummaryProvider.overrideWithValue(
          AsyncValue.data(mockMonthlySummary),
        ),
        categoryExpensesProvider.overrideWithValue(
          AsyncValue.data(mockCategoryExpenses),
        ),
        recentTransactionsProvider.overrideWithValue(
          AsyncValue.data(mockTransactions),
        ),
      ],
      child: MaterialApp(
        home: const HomeScreen(),
        routes: {
          '/transaction/add': (context) => const Scaffold(body: Text('Add Transaction')),
          '/transaction/details': (context) => const Scaffold(body: Text('Transaction Details')),
        },
      ),
    ),
  );
  
  // 主要なUIコンポーネントの表示を検証
  expect(find.text('2025年5月'), findsOneWidget);
  expect(find.text('¥1,000'), findsOneWidget); // 収入
  expect(find.text('¥600'), findsOneWidget); // 支出
  expect(find.text('¥400'), findsOneWidget); // 残高
  
  expect(find.text('食費'), findsOneWidget);
  expect(find.text('交通費'), findsOneWidget);
  expect(find.text('光熱費'), findsOneWidget);
  
  expect(find.text('スーパーでの買い物'), findsOneWidget);
  expect(find.text('給料'), findsOneWidget);
  
  // インタラクションのテスト
  await tester.tap(find.byIcon(Icons.add));
  await tester.pumpAndSettle();
  
  expect(find.text('Add Transaction'), findsOneWidget);
});
```

### 9.3 統合テスト

ホーム画面とデータリポジトリの統合テスト、およびユーザー操作のシナリオテストを実施します。

---

## 10. 変更履歴

| 日付       | 変更内容               | 担当者 |
| ---------- | ---------------------- | ------ |
| 2025-05-16 | 初版リリース           | 廣澤   |
      body: SafeArea(
        child: RefreshIndicator(
          onRefresh: () async {
            // データの再取得処理
            ref.refresh(monthlySummaryProvider);
            ref.refresh(categorySummaryProvider);
          },
          child: ListView(
            padding: const EdgeInsets.all(16.0),
            children: [
              _buildMonthSelector(context, ref),
              const SizedBox(height: 16),
              _buildMonthlySummaryCard(context, ref),
              const SizedBox(height: 24),
              _buildCategoryCharts(context, ref),
              const SizedBox(height: 24),
              _buildRecentTransactions(context, ref),
            ],
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.of(context).pushNamed('/transaction/add'),
        child: const Icon(Icons.add),
      ),
      bottomNavigationBar: const AppBottomNavigation(currentIndex: 0),
    );
  }
  
  // 以下、各セクションの実装メソッド
}
```

### 3.2 各コンポーネント実装

#### 3.2.1 アプリバー

```dart
PreferredSizeWidget _buildAppBar(BuildContext context, WidgetRef ref) {
  final user = ref.watch(currentUserProvider);
  final unreadNotificationCount = ref.watch(unreadNotificationCountProvider);
  
  return AppBar(
    title: const Text('ホーム'),
    actions: [
      // 通知アイコン
      Stack(
        alignment: Alignment.center,
        children: [
          IconButton(
            icon: const Icon(Icons.notifications),
            onPressed: () => Navigator.of(context).pushNamed('/notifications'),
          ),
          if (unreadNotificationCount > 0)
            Positioned(
              top: 8,
              right: 8,
              child: Container(
                padding: const EdgeInsets.all(2),
                decoration: const BoxDecoration(
                  color: Colors.red,
                  shape: BoxShape.circle,
                ),
                constraints: const BoxConstraints(
                  minWidth: 16,
                  minHeight: 16,
                ),
                child: Text(
                  unreadNotificationCount > 9 ? '9+' : unreadNotificationCount.toString(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 10,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
            ),
        ],
      ),
      // ユーザーアイコン
      GestureDetector(
        onTap: () => Navigator.of(context).pushNamed('/settings'),
        child: Padding(
          padding: const EdgeInsets.only(right: 16.0),
          child: CircleAvatar(
            radius: 16,
            backgroundImage: user?.photoUrl != null
                ? NetworkImage(user!.photoUrl!)
                : null,
            child: user?.photoUrl == null
                ? const Icon(Icons.person, size: 16)
                : null,
          ),
        ),
      ),
    ],
  );
}
```

#### 3.2.2 月選択セレクター

```dart
Widget _buildMonthSelector(BuildContext context, WidgetRef ref) {
  final selectedDate = ref.watch(selectedDateProvider);
  final notifier = ref.read(selectedDateProvider.notifier);
  
  return Card(
    child: Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          IconButton(
            icon: const Icon(Icons.chevron_left),
            onPressed: () => notifier.previousMonth(),
          ),
          GestureDetector(
            onTap: () async {
              final picked = await showMonthPicker(
                context: context, 
                initialDate: selectedDate,
              );
              if (picked != null) {
                notifier.setDate(picked);
              }
            },
            child: Text(
              DateFormat('yyyy年MM月').format(selectedDate),
              style: Theme.of(context).textTheme.titleLarge,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.chevron_right),
            onPressed: () => notifier.nextMonth(),
            // 翌月が未来の場合は無効化
            color: selectedDate.month == DateTime.now().month && 
                   selectedDate.year == DateTime.now().year
                ? Colors.grey
                : null,
          ),
        ],
      ),
    ),
  );
}
```

#### 3.2.3 月間サマリーカード

```dart
Widget _buildMonthlySummaryCard(BuildContext context, WidgetRef ref) {
  final selectedDate = ref.watch(selectedDateProvider);
  final summaryAsyncValue = ref.watch(
    monthlySummaryProvider(
      (year: selectedDate.year, month: selectedDate.month)
    )
  );
  
  return Card(
    elevation: 2,
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    child: Padding(
      padding: const EdgeInsets.all(16.0),
      child: summaryAsyncValue.when(
        data: (summary) => Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '今月の収支',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            _buildSummaryRow(
              context, 
              '収入', 
              summary.totalIncome,
              Colors.green,
            ),
            const Divider(),
            _buildSummaryRow(
              context, 
              '支出', 
              summary.totalExpense,
              Colors.red,
            ),
            const Divider(),
            _buildSummaryRow(
              context, 
              '残高', 
              summary.balance,
              summary.balance >= 0 ? Colors.blue : Colors.orange,
            ),
            if (summary.budgetAmount != null) ...[
              const Divider(),
              const SizedBox(height: 8),
              Text(
                '予算進捗',
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              _buildBudgetProgressBar(context, summary),
            ],
          ],
        ),
        loading: () => const Center(
          heightFactor: 2,
          child: CircularProgressIndicator(),
        ),
        error: (error, stackTrace) => Center(
          heightFactor: 2,
          child: Text('データの取得に失敗しました: $error'),
        ),
      ),
    ),
  );
}

Widget _buildSummaryRow(
  BuildContext context, 
  String label, 
  double amount, 
  Color color,
) {
  final currencyCode = ref.watch(currencyCodeProvider);
  final formatter = NumberFormat.currency(
    locale: 'ja_JP',
    symbol: currencyCode == 'JPY' ? '¥' : '\$',
    decimalDigits: currencyCode == 'JPY' ? 0 : 2,
  );
  
  return Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
      Text(
        label,
        style: Theme.of(context).textTheme.bodyLarge,
      ),
      Text(
        formatter.format(amount),
        style: Theme.of(context).textTheme.titleMedium!.copyWith(
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    ],
  );
}

Widget _buildBudgetProgressBar(
  BuildContext context, 
  MonthlySummary summary,
) {
  final percentage = summary.budgetUsageRate * 100;
  final isOverBudget = percentage > 100;
  
  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text('予算: ${NumberFormat.currency(
            locale: 'ja_JP',
            symbol: '¥',
            decimalDigits: 0,
          ).format(summary.budgetAmount ?? 0)}'),
          Text(
            '${percentage.toStringAsFixed(1)}%',
            style: TextStyle(
              color: isOverBudget ? Colors.red : Colors.green,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
      const SizedBox(height: 8),
      LinearProgressIndicator(
        value: summary.budgetUsageRate.clamp(0.0, 1.0),
        backgroundColor: Colors.grey[300],
        valueColor: AlwaysStoppedAnimation<Color>(
          isOverBudget ? Colors.red : Colors.green,
        ),
      ),
    ],
  );
}
```

#### 3.2.4 カテゴリ別チャート

```dart
Widget _buildCategoryCharts(BuildContext context, WidgetRef ref) {
  final selectedDate = ref.watch(selectedDateProvider);
  final chartTypeState = useState(0); // 0: 円グラフ, 1: 棒グラフ
  final categoryType = useState<TransactionType>(TransactionType.expense);
  
  final categorySummaryAsyncValue = ref.watch(
    categorySummaryProvider(
      (
        year: selectedDate.year, 
        month: selectedDate.month, 
        type: categoryType.value
      )
    )
  );
  
  return Card(
    elevation: 2,
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    child: Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'カテゴリ別グラフ',
                style: Theme.of(context).textTheme.titleMedium,
              ),
              SegmentedButton<int>(
                segments: const [
                  ButtonSegment(
                    value: 0,
                    icon: Icon(Icons.pie_chart),
                  ),
                  ButtonSegment(
                    value: 1,
                    icon: Icon(Icons.bar_chart),
                  ),
                ],
                selected: {chartTypeState.value},
                onSelectionChanged: (value) {
                  chartTypeState.value = value.first;
                },
              ),
            ],
          ),
          const SizedBox(height: 16),
          SegmentedButton<TransactionType>(
            segments: const [
              ButtonSegment(
                value: TransactionType.expense,
                label: Text('支出'),
              ),
              ButtonSegment(
                value: TransactionType.income,
                label: Text('収入'),
              ),
            ],
            selected: {categoryType.value},
            onSelectionChanged: (value) {
              categoryType.value = value.first;
            },
          ),
          const SizedBox(height: 16),
          SizedBox(
            height: 250,
            child: categorySummaryAsyncValue.when(
              data: (categorySummaries) {
                if (categorySummaries.isEmpty) {
                  return const Center(
                    child: Text('データがありません'),
                  );
                }
                
                return chartTypeState.value == 0
                    ? _buildPieChart(context, categorySummaries)
                    : _buildBarChart(context, categorySummaries);
              },
              loading: () => const Center(
                child: CircularProgressIndicator(),
              ),
              error: (error, stackTrace) => Center(
                child: Text('データの取得に失敗しました: $error'),
              ),
            ),
          ),
        ],
      ),
    ),
  );
}

Widget _buildPieChart(
  BuildContext context,
  List<CategorySummary> categorySummaries,
) {
  // FL Chartを使ったパイチャート実装
  return PieChart(
    PieChartData(
      sections: categorySummaries.map((summary) {
        final color = _getCategoryColor(summary.colorCode);
        return PieChartSectionData(
          value: summary.amount,
          title: '${summary.percentage * 100}%',
          color: color,
          radius: 100,
          titleStyle: const TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        );
      }).toList(),
      centerSpaceRadius: 40,
      sectionsSpace: 2,
    ),
    swapAnimationDuration: const Duration(milliseconds: 300),
  );
}

Widget _buildBarChart(
  BuildContext context,
  List<CategorySummary> categorySummaries,
) {
  // FL Chartを使った棒グラフ実装
  return BarChart(
    BarChartData(
      barGroups: categorySummaries.asMap().entries.map((entry) {
        final index = entry.key;
        final summary = entry.value;
        final color = _getCategoryColor(summary.colorCode);
        
        return BarChartGroupData(
          x: index,
          barRods: [
            BarChartRodData(
              toY: summary.amount,
              color: color,
              width: 16,
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(4),
                topRight: Radius.circular(4),
              ),
            ),
          ],
        );
      }).toList(),
      titlesData: FlTitlesData(
        leftTitles: AxisTitles(
          sideTitles: SideTitles(showTitles: true),
        ),
        bottomTitles: AxisTitles(
          sideTitles: SideTitles(
            showTitles: true,
            getTitlesWidget: (value, meta) {
              final index = value.toInt();
              if (index >= 0 && index < categorySummaries.length) {
                return Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(
                    categorySummaries[index].categoryName,
                    style: const TextStyle(fontSize: 10),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                );
              }
              return const Text('');
            },
          ),
        ),
        rightTitles: AxisTitles(
          sideTitles: SideTitles(showTitles: false),
        ),
        topTitles: AxisTitles(
          sideTitles: SideTitles(showTitles: false),
        ),
      ),
      gridData: FlGridData(show: false),
      borderData: FlBorderData(show: false),
    ),
  );
}

Color _getCategoryColor(String? colorCode) {
  if (colorCode == null) {
    return Colors.grey;
  }
  
  try {
    return Color(int.parse(colorCode.substring(1), radix: 16) + 0xFF000000);
  } catch (e) {
    return Colors.grey;
  }
}
```

#### 3.2.5 最近の取引リスト

```dart
Widget _buildRecentTransactions(BuildContext context, WidgetRef ref) {
  final selectedDate = ref.watch(selectedDateProvider);
  final transactionsAsyncValue = ref.watch(recentTransactionsProvider);
  
  return Card(
    elevation: 2,
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    child: Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                '最近の取引',
                style: Theme.of(context).textTheme.titleMedium,
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pushNamed('/transactions'),
                child: const Text('すべて表示'),
              ),
            ],
          ),
          const SizedBox(height: 8),
          transactionsAsyncValue.when(
            data: (transactions) {
              if (transactions.isEmpty) {
                return const Padding(
                  padding: EdgeInsets.symmetric(vertical: 16.0),
                  child: Center(
                    child: Text('取引データがありません'),
                  ),
                );
              }
              
              return ListView.separated(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: transactions.length > 5 ? 5 : transactions.length,
                separatorBuilder: (context, index) => const Divider(),
                itemBuilder: (context, index) {
                  final transaction = transactions[index];
                  return TransactionListItem(
                    transaction: transaction,
                    onTap: () => Navigator.of(context).pushNamed(
                      '/transaction/detail',
                      arguments: transaction,
                    ),
                  );
                },
              );
            },
            loading: () => const Center(
              heightFactor: 2,
              child: CircularProgressIndicator(),
            ),
            error: (error, stackTrace) => Center(
              heightFactor: 2,
              child: Text('データの取得に失敗しました: $error'),
            ),
          ),
        ],
      ),
    ),
  );
}
```

### 3.3 Transaction List Item（取引リストアイテム）の実装

```dart
// lib/presentation/widgets/transaction_list_item.dart
class TransactionListItem extends ConsumerWidget {
  final Transaction transaction;
  final VoidCallback? onTap;
  
  const TransactionListItem({
    Key? key,
    required this.transaction,
    this.onTap,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final categoryAsyncValue = ref.watch(
      categoryByIdProvider(transaction.categoryId)
    );
    
    final currencyCode = ref.watch(currencyCodeProvider);
    final formatter = NumberFormat.currency(
      locale: 'ja_JP',
      symbol: currencyCode == 'JPY' ? '¥' : '\$',
      decimalDigits: currencyCode == 'JPY' ? 0 : 2,
    );
    
    return ListTile(
      contentPadding: EdgeInsets.zero,
      leading: categoryAsyncValue.when(
        data: (category) => CircleAvatar(
          backgroundColor: _getCategoryColor(category?.colorCode),
          child: Icon(
            _getCategoryIcon(category?.iconName),
            color: Colors.white,
            size: 20,
          ),
        ),
        loading: () => const CircleAvatar(
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
        error: (_, __) => const CircleAvatar(
          child: Icon(Icons.error),
        ),
      ),
      title: categoryAsyncValue.when(
        data: (category) => Text(category?.name ?? '不明なカテゴリ'),
        loading: () => const Text('読み込み中...'),
        error: (_, __) => const Text('不明なカテゴリ'),
      ),
      subtitle: Text(DateFormat('yyyy/MM/dd').format(transaction.date)),
      trailing: Text(
        formatter.format(
          transaction.type == TransactionType.income
              ? transaction.amount
              : -transaction.amount,
        ),
        style: TextStyle(
          color: transaction.type == TransactionType.income
              ? Colors.green
              : Colors.red,
          fontWeight: FontWeight.bold,
        ),
      ),
      onTap: onTap,
    );
  }
  
  Color _getCategoryColor(String? colorCode) {
    if (colorCode == null) {
      return transaction.type == TransactionType.income
          ? Colors.green
          : Colors.red;
    }
    
    try {
      return Color(int.parse(colorCode.substring(1), radix: 16) + 0xFF000000);
    } catch (e) {
      return transaction.type == TransactionType.income
          ? Colors.green
          : Colors.red;
    }
  }
  
  IconData _getCategoryIcon(String? iconName) {
    switch (iconName) {
      case 'shopping_cart':
        return Icons.shopping_cart;
      case 'restaurant':
        return Icons.restaurant;
      case 'home':
        return Icons.home;
      case 'work':
        return Icons.work;
      case 'directions_bus':
        return Icons.directions_bus;
      case 'movie':
        return Icons.movie;
      case 'school':
        return Icons.school;
      case 'attach_money':
        return Icons.attach_money;
      case 'card_giftcard':
        return Icons.card_giftcard;
      default:
        return transaction.type == TransactionType.income
            ? Icons.arrow_upward
            : Icons.arrow_downward;
    }
  }
}
```

---

## 4. プロバイダー設計

### 4.1 日付選択プロバイダー

```dart
// lib/presentation/state/providers/date_providers.dart
class SelectedDateNotifier extends StateNotifier<DateTime> {
  SelectedDateNotifier() : super(DateTime.now());
  
  void setDate(DateTime date) {
    state = date;
  }
  
  void nextMonth() {
    final currentDate = state;
    if (currentDate.year == DateTime.now().year && 
        currentDate.month == DateTime.now().month) {
      return; // 現在月より先には進めない
    }
    state = DateTime(currentDate.year, currentDate.month + 1);
  }
  
  void previousMonth() {
    final currentDate = state;
    state = DateTime(currentDate.year, currentDate.month - 1);
  }
}

final selectedDateProvider = StateNotifierProvider<SelectedDateNotifier, DateTime>((ref) {
  return SelectedDateNotifier();
});
```

### 4.2 最近の取引プロバイダー

```dart
// lib/presentation/state/providers/transaction_providers.dart
final recentTransactionsProvider = FutureProvider<List<Transaction>>((ref) async {
  final selectedDate = ref.watch(selectedDateProvider);
  final repository = ref.read(transactionRepositoryProvider);
  
  final startDate = DateTime(selectedDate.year, selectedDate.month, 1);
  final endDate = DateTime(selectedDate.year, selectedDate.month + 1, 0);
  
  return repository.getTransactions(
    startDate: startDate,
    endDate: endDate,
    limit: 10, // 最新の10件のみ
  );
});
```

### 4.3 月間サマリープロバイダー

```dart
// lib/presentation/state/providers/summary_providers.dart
final monthlySummaryProvider = FutureProvider.family<MonthlySummary, ({int year, int month})>((ref, params) async {
  final repository = ref.read(transactionRepositoryProvider);
  return repository.getMonthlySummary(params.year, params.month);
});

final categorySummaryProvider = FutureProvider.family<List<CategorySummary>, ({int year, int month, TransactionType type})>((ref, params) async {
  final repository = ref.read(transactionRepositoryProvider);
  return repository.getCategorySummary(params.year, params.month, params.type);
});
```

### 4.4 通知カウントプロバイダー

```dart
// lib/presentation/state/providers/notification_providers.dart
final unreadNotificationCountProvider = FutureProvider<int>((ref) async {
  final repository = ref.read(notificationRepositoryProvider);
  return repository.getUnreadCount();
});
```

---

## 5. 機能とイベントハンドリングの詳細

### 5.1 引っ張り更新機能

```dart
// RefreshIndicatorの実装
RefreshIndicator(
  onRefresh: () async {
    // キャッシュを無効化して再取得
    ref.refresh(monthlySummaryProvider);
    ref.refresh(categorySummaryProvider);
    ref.refresh(recentTransactionsProvider);
    ref.refresh(unreadNotificationCountProvider);
    
    // データ取得操作を実行
    await Future.wait([
      ref.read(monthlySummaryProvider.future),
      ref.read(categorySummaryProvider.future),
      ref.read(recentTransactionsProvider.future),
      ref.read(unreadNotificationCountProvider.future),
    ]);
  },
  child: ListView(/* ... */),
)
```

### 5.2 画面遷移の実装

```dart
// lib/main.dart（ルート定義部分）
final router = GoRouter(
  routes: [
    GoRoute(
      path: '/',
      builder: (context, state) => const HomeScreen(),
    ),
    GoRoute(
      path: '/transaction/add',
      builder: (context, state) => const TransactionFormScreen(),
    ),
    GoRoute(
      path: '/transaction/:id',
      builder: (context, state) {
        final id = state.params['id']!;
        return TransactionDetailScreen(transactionId: id);
      },
    ),
    GoRoute(
      path: '/transactions',
      builder: (context, state) => const TransactionHistoryScreen(),
    ),
    GoRoute(
      path: '/settings',
      builder: (context, state) => const SettingsScreen(),
    ),
    GoRoute(
      path: '/notifications',
      builder: (context, state) => const NotificationsScreen(),
    ),
  ],
);
```

### 5.3 グラフ表示のアニメーション

```dart
// チャートアニメーションの設定
PieChart(
  PieChartData(/* ... */),
  swapAnimationDuration: const Duration(milliseconds: 300), // アニメーション速度
  swapAnimationCurve: Curves.easeInOutQuart, // アニメーションカーブ
)

// 棒グラフのアニメーション
BarChart(
  BarChartData(
    barGroups: /* ... */,
    barTouchData: BarTouchData(
      touchTooltipData: BarTouchTooltipData(
        tooltipBgColor: Colors.blueGrey.withOpacity(0.8),
        getTooltipItem: (group, groupIndex, rod, rodIndex) {
          return BarTooltipItem(
            formatter.format(rod.toY),
            const TextStyle(color: Colors.white),
          );
        },
      ),
    ),
  ),
  swapAnimationDuration: const Duration(milliseconds: 300),
)
```

---

## 6. 画面遷移とデータ連携

### 6.1 収支入力画面への遷移とデータ更新

```dart
FloatingActionButton(
  onPressed: () async {
    // 収支入力画面へ遷移し、結果（登録成功か）を待つ
    final result = await Navigator.of(context).pushNamed('/transaction/add');
    if (result == true) {
      // 登録成功の場合、データを更新
      ref.refresh(recentTransactionsProvider);
      ref.refresh(monthlySummaryProvider);
      ref.refresh(categorySummaryProvider);
    }
  },
  child: const Icon(Icons.add),
)
```

### 6.2 取引詳細画面への遷移とデータ連携

```dart
TransactionListItem(
  transaction: transaction,
  onTap: () async {
    // 取引詳細画面へ遷移
    final result = await Navigator.of(context).pushNamed(
      '/transaction/detail',
      arguments: transaction,
    );
    
    if (result == true) {
      // 編集または削除された場合、データを更新
      ref.refresh(recentTransactionsProvider);
      ref.refresh(monthlySummaryProvider);
      ref.refresh(categorySummaryProvider);
    }
  },
)
```

---

## 7. エラーハンドリングとローディング表示

### 7.1 データ取得エラーのハンドリング

```dart
ref.watch(monthlySummaryProvider).when(
  data: (data) => /* データ表示 */,
  loading: () => const Center(child: CircularProgressIndicator()),
  error: (error, stack) => Center(
    child: Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Icon(Icons.error, size: 48, color: Colors.red),
        const SizedBox(height: 16),
        Text('データの取得に失敗しました'),
        const SizedBox(height: 8),
        ElevatedButton(
          onPressed: () => ref.refresh(monthlySummaryProvider),
          child: const Text('再試行'),
        ),
      ],
    ),
  ),
)
```

### 7.2 スケルトン表示によるローディングUX改善

```dart
Widget _buildMonthlySummaryCardSkeleton() {
  return Card(
    elevation: 2,
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    child: Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const SkeletonLine(width: 120, height: 24),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: const [
              SkeletonLine(width: 80, height: 20),
              SkeletonLine(width: 100, height: 20),
            ],
          ),
          const SizedBox(height: 8),
          const Divider(),
          const SizedBox(height: 8),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: const [
              SkeletonLine(width: 80, height: 20),
              SkeletonLine(width: 100, height: 20),
            ],
          ),
          const SizedBox(height: 8),
          const Divider(),
          const SizedBox(height: 8),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: const [
              SkeletonLine(width: 80, height: 20),
              SkeletonLine(width: 100, height: 20),
            ],
          ),
        ],
      ),
    ),
  );
}

// スケルトン表示用ウィジェット
class SkeletonLine extends StatelessWidget {
  final double width;
  final double height;
  
  const SkeletonLine({
    Key? key,
    required this.width,
    required this.height,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: Colors.grey[300],
        borderRadius: BorderRadius.circular(4),
      ),
    );
  }
}
```

---

## 8. レスポンシブデザイン対応

### 8.1 デバイスサイズに応じたレイアウト調整

```dart
@override
Widget build(BuildContext context) {
  final screenWidth = MediaQuery.of(context).size.width;
  
  // デバイスサイズに応じてレイアウト調整
  if (screenWidth > 600) {
    // タブレットレイアウト
    return Scaffold(
      body: Row(
        children: [
          // サイドナビゲーション（タブレット・デスクトップ用）
          NavigationRail(
            selectedIndex: 0,
            onDestinationSelected: (index) {
              // 画面切替処理
            },
            destinations: const [
              NavigationRailDestination(
                icon: Icon(Icons.home),
                selectedIcon: Icon(Icons.home),
                label: Text('ホーム'),
              ),
              NavigationRailDestination(
                icon: Icon(Icons.history),
                selectedIcon: Icon(Icons.history),
                label: Text('履歴'),
              ),
              NavigationRailDestination(
                icon: Icon(Icons.category),
                selectedIcon: Icon(Icons.category),
                label: Text('カテゴリ'),
              ),
              NavigationRailDestination(
                icon: Icon(Icons.settings),
                selectedIcon: Icon(Icons.settings),
                label: Text('設定'),
              ),
            ],
          ),
          // メインコンテンツ
          Expanded(
            child: Column(
              children: [
                _buildAppBar(context),
                Expanded(
                  child: SingleChildScrollView(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        children: [
                          _buildMonthSelector(context, ref),
                          const SizedBox(height: 16),
                          // タブレット用の2カラムレイアウト
                          Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // 左カラム
                              Expanded(
                                child: _buildMonthlySummaryCard(context, ref),
                              ),
                              const SizedBox(width: 16),
                              // 右カラム
                              Expanded(
                                child: _buildRecentTransactions(context, ref),
                              ),
                            ],
                          ),
                          const SizedBox(height: 24),
                          _buildCategoryCharts(context, ref),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.of(context).pushNamed('/transaction/add'),
        child: const Icon(Icons.add),
      ),
    );
  } else {
    // モバイルレイアウト
    return Scaffold(
      appBar: _buildAppBar(context, ref),
      body: SafeArea(
        child: RefreshIndicator(
          onRefresh: () async {
            // リフレッシュ処理
          },
          child: ListView(
            padding: const EdgeInsets.all(16.0),
            children: [
              _buildMonthSelector(context, ref),
              const SizedBox(height: 16),
              _buildMonthlySummaryCard(context, ref),
              const SizedBox(height: 24),
              _buildCategoryCharts(context, ref),
              const SizedBox(height: 24),
              _buildRecentTransactions(context, ref),
            ],
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.of(context).pushNamed('/transaction/add'),
        child: const Icon(Icons.add),
      ),
      bottomNavigationBar: const AppBottomNavigation(currentIndex: 0),
    );
  }
}
```

### 8.2 グラフサイズの動的調整

```dart
Widget _buildCategoryCharts(BuildContext context, WidgetRef ref) {
  final screenWidth = MediaQuery.of(context).size.width;
  final chartHeight = screenWidth > 600 ? 300.0 : 250.0;
  
  return SizedBox(
    height: chartHeight,
    child: /* チャート表示内容 */,
  );
}
```

---

## 9. UIテストとアクセシビリティ

### 9.1 ウィジェットテスト実装

```dart
// test/screens/home/home_screen_test.dart
void main() {
  testWidgets('ホーム画面には月間サマリー、グラフ、最新取引が表示される', (tester) async {
    // テストで使用するProviderのモックを設定
    final monthlySummary = MonthlySummary(
      year: 2025,
      month: 5,
      totalIncome: 300000,
      totalExpense: 150000,
      balance: 150000,
      budgetAmount: 200000,
      budgetUsageRate: 0.75,
    );
    
    final mockProviders = [
      mockProvider(selectedDateProvider, DateTime(2025, 5, 15)),
      mockProvider(monthlySummaryProvider, AsyncValue.data(monthlySummary)),
      mockProvider(categorySummaryProvider, AsyncValue.data([/* カテゴリサマリーデータ */])),
      mockProvider(recentTransactionsProvider, AsyncValue.data([/* 取引データ */])),
    ];
    
    // テスト実行
    await tester.pumpWidget(
      ProviderScope(
        overrides: mockProviders,
        child: MaterialApp(
          home: HomeScreen(),
        ),
      ),
    );
    
    // 期待される要素が表示されることを確認
    expect(find.text('ホーム'), findsOneWidget);
    expect(find.text('今月の収支'), findsOneWidget);
    expect(find.text('収入'), findsOneWidget);
    expect(find.text('支出'), findsOneWidget);
    expect(find.text('残高'), findsOneWidget);
    expect(find.text('¥300,000'), findsOneWidget);
    expect(find.text('¥150,000'), findsOneWidget);
    expect(find.text('予算進捗'), findsOneWidget);
    expect(find.text('75.0%'), findsOneWidget);
  });
}
```

### 9.2 アクセシビリティサポート

```dart
// グラフのセマンティクスラベル設定（スクリーンリーダー対応）
SemanticsWrapper(
  label: 'カテゴリ別支出グラフ: 食費 30%, 住居費 25%, 交通費 15%, その他 30%',
  child: PieChart(/* ... */),
)

// コントラスト改善のための色設定
final lightModeColorScheme = ColorScheme.fromSeed(
  seedColor: Colors.blue,
  brightness: Brightness.light,
);

final darkModeColorScheme = ColorScheme.fromSeed(
  seedColor: Colors.blue,
  brightness: Brightness.dark,
);

// アクセシビリティ対応ヘルパーウィジェット
class SemanticsWrapper extends StatelessWidget {
  final String label;
  final Widget child;
  
  const SemanticsWrapper({
    Key? key, 
    required this.label,
    required this.child,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Semantics(
      label: label,
      child: ExcludeSemantics(
        child: child,
      ),
    );
  }
}
```

---

## 10. 変更履歴

| 日付       | 変更内容               | 担当者 |
| ---------- | ---------------------- | ------ |
| 2025-05-16 | 初版リリース           | 廣澤  |
